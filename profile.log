SCRIPT  /tmp/coc-30264.vim
Sourced 1 time
Total time:   0.000565
 Self time:   0.000565

count  total (s)   self (s)
                            
    1              0.000008 augroup coc_autocmd
    1              0.000414   autocmd!
    1              0.000036   autocmd BufReadCmd,FileReadCmd,SourceCmd output://* call coc#rpc#request('CocAutocmd', ['BufReadCmd','output', expand('<amatch>')])
    1              0.000029 autocmd BufReadCmd,FileReadCmd,SourceCmd coc://* call coc#rpc#request('CocAutocmd', ['BufReadCmd','coc', expand('<amatch>')])
    1              0.000018 autocmd OptionSet runtimepath call coc#rpc#notify('OptionSet',[expand('<amatch>'), v:option_old, v:option_new])
    1              0.000017 autocmd OptionSet iskeyword call coc#rpc#notify('OptionSet',[expand('<amatch>'), v:option_old, v:option_new])
    1              0.000019 autocmd OptionSet completeopt call coc#rpc#notify('OptionSet',[expand('<amatch>'), v:option_old, v:option_new])
    1              0.000004 augroup end
SCRIPT  /home/knucker/.vim/pack/coc/start/coc.nvim-release/autoload/coc.vim
Sourced 1 time
Total time:   0.000638
 Self time:   0.000638

count  total (s)   self (s)
    1              0.000024 let g:coc#_context = {'start': 0, 'preselect': -1,'candidates': []}
    1              0.000014 let g:coc_user_config = get(g:, 'coc_user_config', {})
    1              0.000022 let g:coc_global_extensions = get(g:, 'coc_global_extensions', [])
    1              0.000006 let g:coc_selected_text = ''
    1              0.000006 let g:coc_vim_commands = []
    1              0.000006 let s:watched_keys = []
    1              0.000020 let s:is_vim = !has('nvim')
    1              0.000021 let s:error_sign = get(g:, 'coc_status_error_sign', has('mac') ? '❌ ' : 'E')
    1              0.000020 let s:warning_sign = get(g:, 'coc_status_warning_sign', has('mac') ? '⚠️ ' : 'W')
    1              0.000015 let s:select_api = exists('*nvim_select_popupmenu_item')
    1              0.000006 let s:callbacks = {}
                            
    1              0.000008 function! coc#expandable() abort
                              return coc#rpc#request('snippetCheck', [1, 0])
                            endfunction
                            
    1              0.000005 function! coc#jumpable() abort
                              return coc#rpc#request('snippetCheck', [0, 1])
                            endfunction
                            
    1              0.000006 function! coc#expandableOrJumpable() abort
                              return coc#rpc#request('snippetCheck', [1, 1])
                            endfunction
                            
                            " add vim command to CocCommand list
    1              0.000007 function! coc#add_command(id, cmd, ...)
                              let config = {'id':a:id, 'cmd':a:cmd, 'title': get(a:,1,'')}
                              call add(g:coc_vim_commands, config)
                              if !coc#rpc#ready() | return | endif
                              call coc#rpc#notify('addCommand', [config])
                            endfunction
                            
    1              0.000004 function! coc#refresh() abort
                              return "\<c-r>=coc#start()\<CR>"
                            endfunction
                            
    1              0.000005 function! coc#on_enter()
                              if !coc#rpc#ready()
                                return ''
                              endif
                              call coc#rpc#request('CocAutocmd', ['Enter', bufnr('%')])
                              return ''
                            endfunction
                            
    1              0.000006 function! coc#_insert_key(method, key, ...) abort
                              if get(a:, 1, 1)
                                call coc#_cancel()
                              endif
                              return "\<c-r>=coc#rpc#".a:method."('doKeymap', ['".a:key."'])\<CR>"
                            endfunction
                            
    1              0.000004 function! coc#_complete() abort
                              let items = get(g:coc#_context, 'candidates', [])
                              let preselect = get(g:coc#_context, 'preselect', -1)
                              call complete(
                                    \ g:coc#_context.start + 1,
                                    \ items)
                              if s:select_api && len(items) && preselect != -1
                                call nvim_select_popupmenu_item(preselect, v:false, v:false, {})
                              endif
                              return ''
                            endfunction
                            
    1              0.000006 function! coc#_do_complete(start, items, preselect)
                              let g:coc#_context = {
                                    \ 'start': a:start,
                                    \ 'candidates': a:items,
                                    \ 'preselect': a:preselect
                                    \}
                              if mode() =~# 'i'
                                call feedkeys("\<Plug>CocRefresh", 'i')
                              endif
                            endfunction
                            
    1              0.000005 function! coc#_select_confirm()
                              if !exists('##TextChangedP')
                                return "\<C-y>"
                              endif
                              let hasSelected = coc#rpc#request('hasSelected', [])
                              if hasSelected | return "\<C-y>" | endif
                              return "\<down>\<C-y>"
                            endfunction
                            
    1              0.000004 function! coc#_selected()
                              if !pumvisible() | return 0 | endif
                              return coc#rpc#request('hasSelected', [])
                            endfunction
                            
    1              0.000004 function! coc#_hide() abort
                              if !pumvisible() | return | endif
                              call feedkeys("\<C-e>", 'in')
                            endfunction
                            
    1              0.000004 function! coc#_cancel()
                              call coc#util#close_popup()
                              " hack for close pum
                              if pumvisible()
                                let g:coc#_context = {'start': 0, 'preselect': -1,'candidates': []}
                                call feedkeys("\<Plug>CocRefresh", 'i')
                              endif
                            endfunction
                            
    1              0.000004 function! coc#_select() abort
                              if !pumvisible() | return | endif
                              call feedkeys("\<C-y>", 'in')
                            endfunction
                            
    1              0.000004 function! coc#start(...)
                              let opt = coc#util#get_complete_option()
                              call CocActionAsync('startCompletion', extend(opt, get(a:, 1, {})))
                              return ''
                            endfunction
                            
                            " used for statusline
    1              0.000004 function! coc#status()
                              let info = get(b:, 'coc_diagnostic_info', {})
                              let msgs = []
                              if get(info, 'error', 0)
                                call add(msgs, s:error_sign . info['error'])
                              endif
                              if get(info, 'warning', 0)
                                call add(msgs, s:warning_sign . info['warning'])
                              endif
                              return s:trim(join(msgs, ' ') . ' ' . get(g:, 'coc_status', ''))
                            endfunction
                            
    1              0.000007 function! s:trim(str)
                              if exists('*trim')
                                return trim(a:str)
                              endif
                              return substitute(a:str, '\s\+$', '', '')
                            endfunction
                            
    1              0.000006 function! coc#config(section, value)
                              let g:coc_user_config[a:section] = a:value
                              call coc#rpc#notify('updateConfig', [a:section, a:value])
                            endfunction
                            
    1              0.000004 function! coc#add_extension(...)
                              if a:0 == 0 | return | endif
                              call extend(g:coc_global_extensions, a:000)
                            endfunction
                            
    1              0.000004 function! coc#_watch(key)
                              if s:is_vim | return | endif
                              if index(s:watched_keys, a:key) == -1
                                call add(s:watched_keys, a:key)
                                call dictwatcheradd(g:, a:key, function('s:GlobalChange'))
                              endif
                            endfunction
                            
    1              0.000004 function! coc#_unwatch(key)
                              if s:is_vim | return | endif
                              let idx = index(s:watched_keys, a:key)
                              if idx != -1
                                call remove(s:watched_keys, idx)
                                call dictwatcherdel(g:, a:key, function('s:GlobalChange'))
                              endif
                            endfunction
                            
    1              0.000021 function! s:GlobalChange(dict, key, val)
                              call coc#rpc#notify('GlobalChange', [a:key, get(a:val, 'old', v:null), get(a:val, 'new', v:null)])
                            endfunction
                            
    1              0.000004 function! coc#_map()
                              if !s:select_api | return | endif
                              for i in range(1, 9)
                                exe 'inoremap <buffer> '.i.' <Cmd>call nvim_select_popupmenu_item('.(i - 1).', v:true, v:true, {})<cr>'
                              endfor
                            endfunction
                            
    1              0.000004 function! coc#_unmap()
                              if !s:select_api | return | endif
                              for i in range(1, 9)
                                exe 'silent! iunmap <buffer> '.i
                              endfor
                            endfunction
                            
    1              0.000006 function! coc#on_notify(id, method, Cb)
                              let key = a:id. '-'.a:method
                              let s:callbacks[key] = a:Cb
                              call coc#rpc#notify('registNotification', [a:id, a:method])
                            endfunction
                            
    1              0.000006 function! coc#do_notify(id, method, result)
                              let key = a:id. '-'.a:method
                              let Fn = s:callbacks[key]
                              if !empty(Fn)
                                call Fn(a:result)
                              endif
                            endfunction

FUNCTION  airline#extensions#vista#currenttag()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/extensions/vista.vim line 6
Called 94 times
Total time:   0.001609
 Self time:   0.001609

count  total (s)   self (s)
   94              0.000748   if get(w:, 'airline_active', 0)
   94              0.000717     return get(b:, 'vista_nearest_method_or_function', '')
                              endif

FUNCTION  airline#util#has_lawrencium()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/util.vim line 121
Called 94 times
Total time:   0.000904
 Self time:   0.000904

count  total (s)   self (s)
   94              0.000802   return exists('*lawrencium#statusline')

FUNCTION  airline#extensions#coc#get_error()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/extensions/coc.vim line 10
Called 94 times
Total time:   0.008593
 Self time:   0.002353

count  total (s)   self (s)
   94   0.008502   0.002262   return airline#extensions#coc#get('error')

FUNCTION  coc#util#do_autocmd()
    Defined: ~/.vim/pack/coc/start/coc.nvim-release/autoload/coc/util.vim line 729
Called 31 times
Total time:   0.000748
 Self time:   0.000748

count  total (s)   self (s)
   31              0.000555   if exists('#User#'.a:name)
                                exe 'doautocmd User '.a:name
   31              0.000049   endif

FUNCTION  airline#statusline()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline.vim line 190
Called 94 times
Total time:   0.002575
 Self time:   0.002575

count  total (s)   self (s)
   94              0.000990   if has_key(s:contexts, a:winnr)
   94              0.001389     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  airline#check_mode()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline.vim line 199
Called 94 times
Total time:   0.027101
 Self time:   0.027101

count  total (s)   self (s)
   94              0.000890   if !has_key(s:contexts, a:winnr)
                                return ''
   94              0.000158   endif
   94              0.000711   let context = s:contexts[a:winnr]
                            
   94              0.000644   if get(w:, 'airline_active', 1)
   94              0.000632     let l:m = mode(1)
   94              0.000371     if l:m ==# "i"
                                  let l:mode = ['insert']
   94              0.000519     elseif l:m[0] ==# "i"
                                  let l:mode = ['insert']
   94              0.000314     elseif l:m ==# "Rv"
                                  let l:mode =['replace']
   94              0.000437     elseif l:m[0] ==# "R"
                                  let l:mode = ['replace']
   94              0.001569     elseif l:m[0] =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
   94              0.000327     elseif l:m ==# "t"
                                  let l:mode = ['terminal']
   94              0.000456     elseif l:m[0] ==# "c"
                                  let l:mode = ['commandline']
   94              0.000305     elseif l:m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let l:mode = ['normal']
   94              0.000551     elseif l:m[0:1] ==# 'ni'
                                  let l:mode = ['normal']
                                  let l:m = 'ni'
   94              0.000161     else
   94              0.000434       let l:mode = ['normal']
   94              0.000177     endif
   94              0.000781     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let l:m = 'multi'
   94              0.000149     endif
   94              0.001003     if index(['Rv', 'no', 'ni', 'ix', 'ic', 'multi'], l:m) == -1
   94              0.000573       let l:m = l:m[0]
   94              0.000167     endif
   94              0.000908     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
                              else
                                let l:mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
   94              0.000154   endif
                            
   94              0.000571   if g:airline_detect_modified && &modified
                                call add(l:mode, 'modified')
   94              0.000160   endif
                            
   94              0.000363   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
   94              0.000147   endif
                            
   94              0.000782   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
   94              0.000150   endif
                            
   94              0.000471   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
   94              0.000141   endif
                            
   94              0.000319   if &readonly || ! &modifiable
                                call add(l:mode, 'readonly')
   94              0.000150   endif
                            
   94              0.000802   let mode_string = join(l:mode)
   94              0.000746   if get(w:, 'airline_lastmode', '') != mode_string
                                call airline#highlighter#highlight_modified_inactive(context.bufnr)
                                call airline#highlighter#highlight(l:mode, context.bufnr)
                                call airline#util#doautocmd('AirlineModeChanged')
                                let w:airline_lastmode = mode_string
   94              0.000148   endif
                            
   94              0.000224   return ''

FUNCTION  airline#util#append()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/util.vim line 43
Called 658 times
Total time:   0.018814
 Self time:   0.018814

count  total (s)   self (s)
  658              0.004595   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  658              0.001076   endif
  658              0.005041   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
  658              0.005238   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  airline#extensions#branch#update_untracked_config()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/extensions/branch.vim line 167
Called 94 times
Total time:   0.003450
 Self time:   0.003450

count  total (s)   self (s)
   94              0.000960   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
                                return
   94              0.001033   elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
   94              0.000158   endif

FUNCTION  FugitiveWorkTree()
    Defined: ~/.vim/pack/bundles/start/vim-fugitive/plugin/fugitive.vim line 31
Called 188 times
Total time:   0.026633
 Self time:   0.006363

count  total (s)   self (s)
  188   0.026452   0.006182   return s:Tree(FugitiveGitDir(a:0 ? a:1 : -1))

FUNCTION  airline#extensions#fugitiveline#bufname()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/extensions/fugitiveline.vim line 14
Called 94 times
Total time:   0.013004
 Self time:   0.012005

count  total (s)   self (s)
   94              0.000795   if !exists('b:fugitive_name')
                                let b:fugitive_name = ''
                                try
                                  if bufname('%') =~? '^fugitive:' && exists('*FugitiveReal')
                                    let b:fugitive_name = FugitiveReal(bufname('%'))
                                  elseif exists('b:git_dir') && exists('*fugitive#repo')
                                    if get(b:, 'fugitive_type', '') is# 'blob'
                                      let b:fugitive_name = fugitive#repo().translate(FugitivePath(@%, ''))
                                    endif
                                  elseif exists('b:git_dir') && !exists('*fugitive#repo')
                                    let buffer = fugitive#buffer()
                                    if buffer.type('blob')
                                      let b:fugitive_name = buffer.repo().translate(buffer.path('/'))
                                    endif
                                  endif
                                catch
                                endtry
   94              0.000147   endif
                            
   94   0.002992   0.001993   let fmod = s:ModifierFlags()
   94              0.000568   if empty(b:fugitive_name)
   94              0.002668     return fnamemodify(bufname('%'), fmod)
                              else
                                return fnamemodify(b:fugitive_name, fmod). " [git]"
                              endif

FUNCTION  airline#extensions#coc#get_warning()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/extensions/coc.vim line 6
Called 94 times
Total time:   0.008893
 Self time:   0.002339

count  total (s)   self (s)
   94   0.008798   0.002244   return airline#extensions#coc#get('warning')

FUNCTION  coc#util#timer()
    Defined: ~/.vim/pack/coc/start/coc.nvim-release/autoload/coc/util.vim line 263
Called 2 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    2              0.000029   call timer_start(0, { -> s:Call(a:method, a:args)})

FUNCTION  airline#util#has_fugitive()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/util.vim line 117
Called 94 times
Total time:   0.001110
 Self time:   0.001110

count  total (s)   self (s)
   94              0.001010   return exists('*fugitive#head') || exists('*FugitiveHead')

FUNCTION  coc#util#cursor()
    Defined: ~/.vim/pack/coc/start/coc.nvim-release/autoload/coc/util.vim line 90
Called 6 times
Total time:   0.000233
 Self time:   0.000233

count  total (s)   self (s)
    6              0.000054   let pos = getcurpos()
    6              0.000085   let content = pos[2] == 1 ? '' : getline('.')[0: pos[2] - 2]
    6              0.000074   return [pos[1] - 1, strchars(content)]

FUNCTION  airline#parts#filetype()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/parts.vim line 102
Called 94 times
Total time:   0.005314
 Self time:   0.002751

count  total (s)   self (s)
   94   0.005206   0.002643   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  airline#parts#iminsert()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/parts.vim line 82
Called 94 times
Total time:   0.001568
 Self time:   0.001568

count  total (s)   self (s)
   94              0.000613   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
   94              0.000157   endif
   94              0.000249   return ''

FUNCTION  airline#extensions#coc#get()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/extensions/coc.vim line 14
Called 188 times
Total time:   0.012794
 Self time:   0.012794

count  total (s)   self (s)
  188              0.001743   if !exists(":CocCommand")
                                return ''
  188              0.000315   endif
  188              0.001493   let _backup = get(g:, 'coc_stl_format', '')
  188              0.001117   let is_err = (a:type  is# 'error')
  188              0.000532   if is_err
   94              0.000849     let g:coc_stl_format = get(g:, 'airline#extensions#coc#stl_format_err', '%E{[%e(#%fe)]}')
   94              0.000184   else
   94              0.000842     let g:coc_stl_format = get(g:, 'airline#extensions#coc#stl_format_warn', '%W{[%w(#%fw)]}')
  188              0.000335   endif
  188              0.001389   let info = get(b:, 'coc_diagnostic_info', {})
  188              0.001422   if empty(info) | return '' | endif
                            
                            
                              let cnt = get(info, a:type, 0)
                              if !empty(_backup)
                                let g:coc_stl_format = _backup
                              endif
                            
                              if empty(cnt)
                                return ''
                              else
                                return (is_err ? s:error_symbol : s:warning_symbol).cnt
                              endif

FUNCTION  <SNR>80_notify()
    Defined: ~/.vim/pack/coc/start/coc.nvim-release/autoload/coc/client.vim line 133
Called 50 times
Total time:   0.007460
 Self time:   0.006970

count  total (s)   self (s)
   50   0.001502   0.001012   let channel = s:get_channel(self)
   50              0.000498   if empty(channel) | return '' | endif
   50              0.000099   try
   50              0.000141     if s:is_vim
   50              0.002069       call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
                                else
                                  call call('rpcnotify', [channel, a:method] + a:args)
   50              0.000086     endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0) | return | endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
                                endif
   50              0.000117   endtry

FUNCTION  305()
    Defined: ~/.vim/pack/coc/start/coc.nvim-release/autoload/coc/api.vim line 144
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000008   return get(g:, a:var, v:null)

FUNCTION  airline#util#winwidth()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/util.vim line 13
Called 470 times
Total time:   0.012398
 Self time:   0.012398

count  total (s)   self (s)
  470              0.003923   let nr = get(a:000, 0, 0)
  470              0.003095   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
  470              0.000847   else
  470              0.002327     return winwidth(nr)
                              endif

FUNCTION  <SNR>82_Slash()
    Defined: ~/.vim/pack/bundles/start/vim-fugitive/autoload/fugitive.vim line 91
Called 564 times
Total time:   0.010350
 Self time:   0.010350

count  total (s)   self (s)
  564              0.003880   if exists('+shellslash')
                                return tr(a:path, '\', '/')
  564              0.001013   else
  564              0.001856     return a:path
                              endif

FUNCTION  <SNR>89_update_git_branch()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/extensions/branch.vim line 86
Called 94 times
Total time:   0.202973
 Self time:   0.009111

count  total (s)   self (s)
   94   0.003002   0.001892   if !airline#util#has_fugitive()
                                let s:vcs_config['git'].branch = ''
                                return
   94              0.000157   endif
                            
   94   0.192882   0.002655   let s:vcs_config['git'].branch = exists("*FugitiveHead") ? FugitiveHead(s:sha1size) : fugitive#head(s:sha1size)
   94   0.005066   0.002541   if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                " Shorten default a bit
   94              0.000661     let s:vcs_config['git'].branch='mas'
   94              0.000171   endif

FUNCTION  <SNR>89_update_untracked()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/extensions/branch.vim line 176
Called 94 times
Total time:   0.024538
 Self time:   0.021088

count  total (s)   self (s)
   94              0.003020   let file = expand("%:p")
   94              0.001550   if empty(file) || isdirectory(file) || !empty(&buftype)
                                return
   94              0.000157   endif
                            
   94              0.000434   let needs_update = 1
   94              0.000999   let vcs_checks   = get(g:, "airline#extensions#branch#vcs_checks", ["untracked", "dirty"])
  282              0.001353   for vcs in keys(s:vcs_config)
  188              0.002045     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
  188              0.000317     endif
  188              0.001498     if has_key(s:vcs_config[vcs].untracked, file)
   94              0.000367       let needs_update = 0
   94   0.006648   0.003198       call airline#extensions#branch#update_untracked_config(file, vcs)
  188              0.000302     endif
  282              0.000649   endfor
                            
   94              0.000293   if !needs_update
   94              0.000227     return
                              endif
                            
                              for vcs in keys(s:vcs_config)
                                " only check, for git, if fugitive is installed
                                " and for 'hg' if lawrencium is installed, else skip
                                if vcs is# 'git' && !airline#util#has_fugitive()
                                  continue
                                elseif vcs is# 'mercurial' && !airline#util#has_lawrencium()
                                  continue
                                endif
                                let config = s:vcs_config[vcs]
                                " Note that asynchronous update updates s:vcs_config only, and only
                                " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                " invalidated again before s:update_untracked is called, then we lose the
                                " result of the previous call, i.e. the head string is not updated. It
                                " doesn't happen often in practice, so we let it be.
                                if index(vcs_checks, 'untracked') > -1
                                  call airline#async#vcs_untracked(config, file, vcs)
                                endif
                                " Check clean state of repo
                                if index(vcs_checks, 'dirty') > -1
                                  call airline#async#vcs_clean(config.dirty, file, vcs)
                                endif
                              endfor

FUNCTION  <SNR>90_ModifierFlags()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/extensions/fugitiveline.vim line 10
Called 94 times
Total time:   0.000999
 Self time:   0.000999

count  total (s)   self (s)
   94              0.000898   return (exists("+autochdir") && &autochdir) ? ':p' : ':.'

FUNCTION  airline#util#wrap()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/util.vim line 36
Called 658 times
Total time:   0.014578
 Self time:   0.012220

count  total (s)   self (s)
  658   0.008613   0.006255   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  658              0.001117   endif
  658              0.002143   return a:text

FUNCTION  CocActionAsync()
    Defined: ~/.vim/pack/coc/start/coc.nvim-release/plugin/coc.vim line 21
Called 1 time
Total time:   0.000250
 Self time:   0.000020

count  total (s)   self (s)
    1   0.000249   0.000019   return s:AsyncRequest('CocAction', a:000)

FUNCTION  coc#api#call()
    Defined: ~/.vim/pack/coc/start/coc.nvim-release/autoload/coc/api.vim line 531
Called 9 times
Total time:   0.001839
 Self time:   0.000629

count  total (s)   self (s)
    9              0.000130   let err = v:null
    9              0.000042   let res = v:null
    9              0.000026   try
    9   0.001467   0.000257     let res = call(s:funcs[a:method], a:args)
                              catch /.*/
                                let err = v:exception
    9              0.000023   endtry
    9              0.000040   return [err, res]

FUNCTION  FugitiveGitDir()
    Defined: ~/.vim/pack/bundles/start/vim-fugitive/plugin/fugitive.vim line 11
Called 282 times
Total time:   0.015795
 Self time:   0.012421

count  total (s)   self (s)
  282              0.001490   if !a:0 || a:1 ==# -1
   94              0.000706     return get(b:, 'git_dir', '')
  188              0.001289   elseif type(a:1) == type(0)
                                return getbufvar(a:1, 'git_dir')
  188              0.001171   elseif type(a:1) == type('')
  188   0.008816   0.005442     return substitute(s:Slash(a:1), '/$', '', '')
                              else
                                return ''
                              endif

FUNCTION  coc#util#echo_messages()
    Defined: ~/.vim/pack/coc/start/coc.nvim-release/autoload/coc/util.vim line 246
Called 2 times
Total time:   0.000382
 Self time:   0.000382

count  total (s)   self (s)
    2              0.000024   if empty(a:msgs) | return | endif
    2              0.000054   if a:hl !~# 'Error' && (mode() !~# '\v^(i|n)$')
                                return
    2              0.000004   endif
    2              0.000059   execute 'echohl '.a:hl
    2              0.000034   let msgs = filter(copy(a:msgs), '!empty(v:val)')
    4              0.000017   for msg in msgs
    2              0.000126     echom msg
    4              0.000011   endfor
    2              0.000035   echohl None

FUNCTION  airline#extensions#whitespace#check()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/extensions/whitespace.vim line 57
Called 94 times
Total time:   0.002612
 Self time:   0.002612

count  total (s)   self (s)
   94              0.000991   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
   94              0.001144   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
   94              0.000267     return ''
                              endif
                              let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
                              if !exists('b:airline_whitespace_check')
                                let b:airline_whitespace_check = ''
                                let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
                                let trailing = 0
                                let check = 'trailing'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  try
                                    let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
                                    let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
                                  endtry
                                endif
                            
                                let mixed = 0
                                let check = 'indent'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed = s:check_mixed_indent()
                                endif
                            
                                let mixed_file = ''
                                let check = 'mixed-indent-file'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed_file = s:check_mixed_indent_file()
                                endif
                            
                                let long = 0
                                if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
                                let conflicts = 0
                                if index(checks, 'conflicts') > -1
                                  let conflicts = s:conflict_marker()
                                endif
                            
                                if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                    if conflicts != 0
                                      let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                      let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
                                    endif
                                  endif
                                endif
                              endif
                              return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  <SNR>77_AsyncRequest()
    Defined: ~/.vim/pack/coc/start/coc.nvim-release/plugin/coc.vim line 47
Called 1 time
Total time:   0.000230
 Self time:   0.000057

count  total (s)   self (s)
    1              0.000017   let Cb = a:args[len(a:args) - 1]
    1              0.000007   if type(Cb) == 2
                                if !coc#rpc#ready()
                                  call Cb('service not started', v:null)
                                else
                                  call coc#rpc#request_async(a:name, a:args[0:-2], Cb)
                                endif
                                return ''
    1              0.000001   endif
    1   0.000186   0.000013   call coc#rpc#notify(a:name, a:args)
    1              0.000001   return ''

FUNCTION  FugitiveHead()
    Defined: ~/.vim/pack/bundles/start/vim-fugitive/plugin/fugitive.vim line 89
Called 94 times
Total time:   0.190227
 Self time:   0.004882

count  total (s)   self (s)
   94   0.003234   0.001883   let dir = FugitiveGitDir(a:0 > 1 ? a:2 : -1)
   94              0.000468   if empty(dir)
                                return ''
   94              0.000156   endif
   94   0.185861   0.001867   return fugitive#Head(a:0 ? a:1 : 0, dir)

FUNCTION  coc#rpc#ready()
    Defined: ~/.vim/pack/coc/start/coc.nvim-release/autoload/coc/rpc.vim line 26
Called 50 times
Total time:   0.000867
 Self time:   0.000867

count  total (s)   self (s)
   50              0.000665   if empty(s:client) || s:client['running'] == 0 | return 0 | endif
   50              0.000122   return 1

FUNCTION  airline#util#ignore_buf()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/util.vim line 110
Called 94 times
Total time:   0.006581
 Self time:   0.006581

count  total (s)   self (s)
   94              0.001676   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  'gundo|undotree|vimfiler|tagbar|nerd_tree|startify|!')
   94              0.004722   return match(a:name, pat) > -1

FUNCTION  <SNR>60_Tree()
    Defined: ~/.vim/pack/bundles/start/vim-fugitive/plugin/fugitive.vim line 113
Called 188 times
Total time:   0.005826
 Self time:   0.005826

count  total (s)   self (s)
  188              0.001028   let dir = a:path
  188              0.002361   if dir =~# '/\.git$'
  188              0.002123     return len(dir) ==# 5 ? '/' : dir[0:-6]
                              elseif dir ==# ''
                                return ''
                              endif
                              if !has_key(s:worktree_for_dir, dir)
                                let s:worktree_for_dir[dir] = ''
                                let config_file = dir . '/config'
                                if filereadable(config_file)
                                  let config = readfile(config_file,'',10)
                                  call filter(config,'v:val =~# "^\\s*worktree *="')
                                  if len(config) == 1
                                    let worktree = matchstr(config[0], '= *\zs.*')
                                  endif
                                elseif filereadable(dir . '/gitdir')
                                  let worktree = fnamemodify(readfile(dir . '/gitdir')[0], ':h')
                                  if worktree ==# '.'
                                    unlet! worktree
                                  endif
                                endif
                                if exists('worktree')
                                  let s:worktree_for_dir[dir] = worktree
                                  let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                endif
                              endif
                              if s:worktree_for_dir[dir] =~# '^\.'
                                return simplify(dir . '/' . s:worktree_for_dir[dir])
                              else
                                return s:worktree_for_dir[dir]
                              endif

FUNCTION  <SNR>89_update_branch()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/extensions/branch.vim line 157
Called 94 times
Total time:   0.234374
 Self time:   0.013356

count  total (s)   self (s)
  282              0.001509   for vcs in keys(s:vcs_config)
  188   0.226322   0.005304     call {s:vcs_config[vcs].update_branch}()
  188              0.001791     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
                                  let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
                                  unlet! b:airline_head
  188              0.000303     endif
  282              0.000593   endfor

FUNCTION  airline#update_tabline()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline.vim line 273
Called 48 times
Total time:   0.000760
 Self time:   0.000760

count  total (s)   self (s)
   48              0.000384   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
   48              0.000079   endif

FUNCTION  <SNR>80_get_channel()
    Defined: ~/.vim/pack/coc/start/coc.nvim-release/autoload/coc/client.vim line 94
Called 50 times
Total time:   0.000490
 Self time:   0.000490

count  total (s)   self (s)
   50              0.000180   if s:is_vim
   50              0.000242     return a:client['channel']
                              endif
                              return a:client['chan_id']

FUNCTION  airline#parts#get()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/parts.vim line 49
Called 94 times
Total time:   0.000987
 Self time:   0.000987

count  total (s)   self (s)
   94              0.000892   return get(s:parts, a:key, {})

FUNCTION  airline#parts#paste()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/parts.vim line 63
Called 94 times
Total time:   0.000772
 Self time:   0.000772

count  total (s)   self (s)
   94              0.000674   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  <SNR>77_Autocmd()
    Defined: ~/.vim/pack/coc/start/coc.nvim-release/plugin/coc.vim line 124
Called 49 times
Total time:   0.011701
 Self time:   0.001459

count  total (s)   self (s)
   49              0.000560   if !get(g:,'coc_workspace_initialized', 0) | return | endif
   49   0.011079   0.000837   call coc#rpc#notify('CocAutocmd', a:000)

FUNCTION  fugitive#CommonDir()
    Defined: ~/.vim/pack/bundles/start/vim-fugitive/autoload/fugitive.vim line 276
Called 188 times
Total time:   0.012453
 Self time:   0.012453

count  total (s)   self (s)
  188              0.001104   if empty(a:dir)
                                return ''
  188              0.000311   endif
  188              0.001289   if !has_key(s:commondirs, a:dir)
                                if getfsize(a:dir . '/HEAD') < 10
                                  let s:commondirs[a:dir] = ''
                                elseif filereadable(a:dir . '/commondir')
                                  let dir = get(readfile(a:dir . '/commondir', 1), 0, '')
                                  if dir =~# '^/\|^\a:/'
                                    let s:commondirs[a:dir] = dir
                                  else
                                    let s:commondirs[a:dir] = simplify(a:dir . '/' . dir)
                                  endif
                                else
                                  let s:commondirs[a:dir] = a:dir
                                endif
  188              0.000279   endif
  188              0.001057   return s:commondirs[a:dir]

FUNCTION  <SNR>82_Tree()
    Defined: ~/.vim/pack/bundles/start/vim-fugitive/autoload/fugitive.vim line 301
Called 188 times
Total time:   0.030809
 Self time:   0.004176

count  total (s)   self (s)
  188   0.030646   0.004013   return a:0 ? FugitiveWorkTree(a:1) : FugitiveWorkTree()

FUNCTION  airline#parts#readonly()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/parts.vim line 89
Called 94 times
Total time:   0.011597
 Self time:   0.005016

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
   94   0.009318   0.002737   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
                                return ''
   94              0.000167   endif
   94              0.000524   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
   94              0.000156   else
   94              0.000435     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  fugitive#Head()
    Defined: ~/.vim/pack/bundles/start/vim-fugitive/autoload/fugitive.vim line 469
Called 94 times
Total time:   0.183994
 Self time:   0.014693

count  total (s)   self (s)
   94              0.000839   let dir = a:0 > 1 ? a:2 : s:Dir()
   94   0.090160   0.004453   if empty(dir) || !filereadable(fugitive#Find('.git/HEAD', dir))
                                return ''
   94              0.000161   endif
   94   0.088418   0.004824   let head = readfile(fugitive#Find('.git/HEAD', dir))[0]
   94              0.001214   if head =~# '^ref: '
   94              0.002628     return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                              elseif head =~# '^\x\{40,\}$'
                                let len = a:0 ? a:1 : 0
                                return len < 0 ? head : len ? head[0:len-1] : ''
                              else
                                return ''
                              endif

FUNCTION  <SNR>103_execute()
    Defined: ~/.vim/pack/coc/start/coc.nvim-release/autoload/coc/api.vim line 22
Called 30 times
Total time:   0.165404
 Self time:   0.165404

count  total (s)   self (s)
   30              0.000270   if a:cmd =~# '^echo'
                                execute a:cmd
   30              0.000049   else
   30              0.164848     silent! execute a:cmd
   30              0.000071   endif

FUNCTION  <SNR>60_Slash()
    Defined: ~/.vim/pack/bundles/start/vim-fugitive/plugin/fugitive.vim line 216
Called 188 times
Total time:   0.003374
 Self time:   0.003374

count  total (s)   self (s)
  188              0.001273   if exists('+shellslash')
                                return tr(a:path, '\', '/')
  188              0.000328   else
  188              0.000622     return a:path
                              endif

FUNCTION  293()
    Defined: ~/.vim/pack/coc/start/coc.nvim-release/autoload/coc/api.vim line 90
Called 35 times
Total time:   0.001727
 Self time:   0.000906

count  total (s)   self (s)
   35   0.001688   0.000867   return call(a:method, a:args)

FUNCTION  coc#api#notify()
    Defined: ~/.vim/pack/coc/start/coc.nvim-release/autoload/coc/api.vim line 542
Called 34 times
Total time:   0.010964
 Self time:   0.001518

count  total (s)   self (s)
   34   0.010829   0.001383   call call(s:funcs[a:method], a:args)

FUNCTION  airline#parts#spell()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/parts.vim line 67
Called 94 times
Total time:   0.005792
 Self time:   0.005792

count  total (s)   self (s)
   94              0.002230   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
   94              0.000519   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
   94              0.000141   endif
   94              0.000214   return ''

FUNCTION  <SNR>89_update_hg_branch()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/extensions/branch.vim line 122
Called 94 times
Total time:   0.018045
 Self time:   0.017141

count  total (s)   self (s)
   94   0.002932   0.002028   if airline#util#has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    noa call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    noa call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    noa call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
   94              0.000164   else
   94              0.000609     let s:vcs_config['mercurial'].branch = ''
   94              0.000175   endif

FUNCTION  <SNR>92_ws_refresh()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/extensions/whitespace.vim line 178
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000007   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
    1              0.000002     return
                              endif
                              unlet! b:airline_whitespace_check
                              if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
                              endif
                              let b:airline_ws_changedtick = b:changedtick

FUNCTION  airline#parts#crypt()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/parts.vim line 59
Called 94 times
Total time:   0.001302
 Self time:   0.001302

count  total (s)   self (s)
   94              0.001177   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  airline#extensions#keymap#status()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/extensions/keymap.vim line 10
Called 94 times
Total time:   0.002779
 Self time:   0.002779

count  total (s)   self (s)
   94              0.001399   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
   94              0.001209     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  <SNR>22_Highlight_Matching_Pair()
    Defined: /usr/share/vim/vim81/plugin/matchparen.vim line 39
Called 48 times
Total time:   0.009643
 Self time:   0.009643

count  total (s)   self (s)
                              " Remove any previous match.
   48              0.000633   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
   48              0.000108   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   48              0.000472   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   48              0.000069   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   48              0.000331   let c_lnum = line('.')
   48              0.000294   let c_col = col('.')
   48              0.000203   let before = 0
                            
   48              0.000348   let text = getline(c_lnum)
   48              0.001606   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   48              0.000271   if empty(matches)
                                let [c_before, c] = ['', '']
   48              0.000092   else
   48              0.000539     let [c_before, c] = matches[1:2]
   48              0.000091   endif
   48              0.001258   let plist = split(&matchpairs, '.\zs[:,]')
   48              0.000404   let i = index(plist, c)
   48              0.000155   if i < 0
                                " not found, in Insert mode try character before the cursor
   48              0.000293     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
   48              0.000083     endif
   48              0.000135     if i < 0
                                  " not found, nothing to do
   48              0.000119       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  airline#extensions#branch#head()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/extensions/branch.vim line 223
Called 94 times
Total time:   0.266308
 Self time:   0.007396

count  total (s)   self (s)
   94              0.000794   if !exists('b:buffer_vcs_config')
                                call s:init_buffer()
   94              0.000161   endif
                            
   94   0.236214   0.001840   call s:update_branch()
   94   0.026892   0.002354   call s:update_untracked()
                            
   94              0.000938   if exists('b:airline_head') && !empty(b:airline_head)
   94              0.000388     return b:airline_head
                              endif
                            
                              let b:airline_head = ''
                              let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
                              let heads = []
                              for vcs in vcs_priority
                                if !empty(b:buffer_vcs_config[vcs].branch)
                                  let heads += [vcs]
                                endif
                              endfor
                            
                              for vcs in heads
                                if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
                                endif
                                if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
                                endif
                                let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
                                let additional = b:buffer_vcs_config[vcs].untracked
                                if empty(additional) && has_key(b:buffer_vcs_config[vcs], 'dirty') && b:buffer_vcs_config[vcs].dirty
                                  let additional = g:airline_symbols['dirty']
                                endif
                                let b:airline_head .= additional
                              endfor
                            
                              if empty(heads)
                                if airline#util#has_vcscommand()
                                  noa call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
                              endif
                            
                              if empty(heads)
                                if airline#util#has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
                                endif
                              endif
                            
                              if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if len(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = b:airline_head[0:(w:displayed_head_limit - 1)].(&encoding ==? 'utf-8' ?  '…' : '.')
                                endif
                              endif
                            
                              return b:airline_head

FUNCTION  airline#parts#mode()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/parts.vim line 55
Called 94 times
Total time:   0.009900
 Self time:   0.002557

count  total (s)   self (s)
   94   0.009803   0.002460   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  <SNR>79_Call()
    Defined: ~/.vim/pack/coc/start/coc.nvim-release/autoload/coc/util.vim line 267
Called 2 times
Total time:   0.000460
 Self time:   0.000078

count  total (s)   self (s)
    2              0.000006   try
    2   0.000425   0.000043     call call(a:method, a:args)
    2              0.000010     redraw
                              catch /.*/
                                return 0
    2              0.000004   endtry

FUNCTION  <SNR>55_on_cursor_moved()
    Defined: ~/.vim/pack/bundles/start/vim-airline/plugin/airline.vim line 74
Called 48 times
Total time:   0.002438
 Self time:   0.001678

count  total (s)   self (s)
   48              0.000352   if winnr() != s:active_winnr
                                call s:on_window_changed('CursorMoved')
   48              0.000090   endif
   48   0.001630   0.000870   call airline#update_tabline()

FUNCTION  fugitive#Find()
    Defined: ~/.vim/pack/bundles/start/vim-fugitive/autoload/fugitive.vim line 809
Called 188 times
Total time:   0.169301
 Self time:   0.112085

count  total (s)   self (s)
  188              0.001615   if type(a:object) == type(0)
                                let name = bufname(a:object)
                                return s:PlatformSlash(name =~# '^$\|^/\|^\a\+:' ? name : getcwd() . '/' . name)
  188              0.002201   elseif a:object =~# '^[~$]'
                                let prefix = matchstr(a:object, '^[~$]\i*')
                                let owner = expand(prefix)
                                return s:PlatformSlash((len(owner) ? owner : prefix) . strpart(a:object, len(prefix)))
  188   0.011821   0.008289   elseif s:Slash(a:object) =~# '^$\|^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                return s:PlatformSlash(a:object)
  188   0.008475   0.005055   elseif s:Slash(a:object) =~# '^\.\.\=\%(/\|$\)'
                                return s:PlatformSlash(simplify(getcwd() . '/' . a:object))
  188              0.000354   endif
  188              0.001360   let dir = a:0 ? a:1 : s:Dir()
  188              0.000906   if empty(dir)
                                let file = matchstr(a:object, '^\%(:\d:\|[^:]*:\)\zs.*', '', '')
                                let dir = FugitiveExtractGitDir(file)
                                if empty(dir)
                                  return fnamemodify(len(file) ? file : a:object, ':p')
                                endif
  188              0.000290   endif
  188   0.006802   0.003404   let rev = s:Slash(a:object)
  188   0.034281   0.003472   let tree = s:Tree(dir)
  188              0.001532   let base = len(tree) ? tree : 'fugitive://' . dir . '//0'
  188              0.000643   if rev ==# '.git'
                                let f = len(tree) ? tree . '/.git' : dir
  188              0.002112   elseif rev =~# '^\.git/'
  188              0.002844     let f = substitute(rev, '^\.git', '', '')
  188   0.016140   0.003687     let cdir = fugitive#CommonDir(dir)
  188              0.002351     if f =~# '^/\.\./\.\.\%(/\|$\)'
                                  let f = simplify(len(tree) ? tree . f[3:-1] : dir . f)
  188              0.001905     elseif f =~# '^/\.\.\%(/\|$\)'
                                  let f = base . f[3:-1]
  188              0.002185     elseif cdir !=# dir && ( f =~# '^/\%(config\|hooks\|info\|logs/refs\|objects\|refs\|worktrees\)\%(/\|$\)' || f !~# '^/\%(index$\|index\.lock$\|\w*MSG$\|\w*HEAD$\|logs/\w*HEAD$\|logs$\|rebase-\w\+\)\%(/\|$\)' && getftime(dir . f) < 0 && getftime(cdir . f) >= 0)
                                  let f = simplify(cdir . f)
  188              0.000328     else
  188              0.001455       let f = simplify(dir . f)
  188              0.000343     endif
                              elseif rev ==# ':/'
                                let f = base
                              elseif rev =~# '^\.\%(/\|$\)'
                                let f = base . rev[1:-1]
                              elseif rev =~# '^::\%(/\|\a\+\:\)'
                                let f = rev[2:-1]
                              elseif rev =~# '^::\.\.\=\%(/\|$\)'
                                let f = simplify(getcwd() . '/' . rev[2:-1])
                              elseif rev =~# '^::'
                                let f = base . '/' . rev[2:-1]
                              elseif rev =~# '^:\%([0-3]:\)\=\.\.\=\%(/\|$\)\|^:[0-3]:\%(/\|\a\+:\)'
                                let f = rev =~# '^:\%([0-3]:\)\=\.' ? simplify(getcwd() . '/' . matchstr(rev, '\..*')) : rev[3:-1]
                                if s:cpath(base . '/', (f . '/')[0 : len(base)])
                                  let f = 'fugitive://' . dir . '//' . +matchstr(rev, '^:\zs\d\ze:') . '/' . strpart(f, len(base) + 1)
                                else
                                  let altdir = FugitiveExtractGitDir(f)
                                  if len(altdir) && !s:cpath(dir, altdir)
                                    return fugitive#Find(a:object, altdir)
                                  endif
                                endif
                              elseif rev =~# '^:[0-3]:'
                                let f = 'fugitive://' . dir . '//' . rev[1] . '/' . rev[3:-1]
                              elseif rev ==# ':'
                                if $GIT_INDEX_FILE =~# '/[^/]*index[^/]*\.lock$' && s:cpath(fnamemodify($GIT_INDEX_FILE,':p')[0:strlen(dir)]) ==# s:cpath(dir . '/') && filereadable($GIT_INDEX_FILE)
                                  let f = fnamemodify($GIT_INDEX_FILE, ':p')
                                else
                                  let f = fugitive#Find('.git/index', dir)
                                endif
                              elseif rev =~# '^:(\%(top\|top,literal\|literal,top\|literal\))'
                                let f = matchstr(rev, ')\zs.*')
                                if f=~# '^\.\.\=\%(/\|$\)'
                                  let f = simplify(getcwd() . '/' . f)
                                elseif f !~# '^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                  let f = base . '/' . f
                                endif
                              elseif rev =~# '^:/\@!'
                                let f = 'fugitive://' . dir . '//0/' . rev[1:-1]
                              else
                                if !exists('f')
                                  let commit = substitute(matchstr(rev, '^[^:]\+\|^:.*'), '^@\%($\|[~^]\|@{\)\@=', 'HEAD', '')
                                  let file = substitute(matchstr(rev, '^[^:]\+\zs:.*'), '^:', '/', '')
                                  if file =~# '^/\.\.\=\%(/\|$\)\|^//\|^/\a\+:'
                                    let file = file =~# '^/\.' ? simplify(getcwd() . file) : file[1:-1]
                                    if s:cpath(base . '/', (file . '/')[0 : len(base)])
                                      let file = '/' . strpart(file, len(base) + 1)
                                    else
                                      let altdir = FugitiveExtractGitDir(file)
                                      if len(altdir) && !s:cpath(dir, altdir)
                                        return fugitive#Find(a:object, altdir)
                                      endif
                                      return file
                                    endif
                                  endif
                                  if commit !~# '^[0-9a-f]\{40,\}$'
                                    let commit = matchstr(s:ChompDefault('', [dir, 'rev-parse', '--verify', commit, '--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if len(commit)
                                    let f = 'fugitive://' . dir . '//' . commit . file
                                  else
                                    let f = base . '/' . substitute(rev, '^:/:\=\|^[^:]\+:', '', '')
                                  endif
                                endif
  188              0.000271   endif
  188   0.007742   0.004138   return s:PlatformSlash(f)

FUNCTION  airline#util#shorten()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/util.vim line 22
Called 188 times
Total time:   0.014500
 Self time:   0.009548

count  total (s)   self (s)
  188   0.009490   0.004538   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
  188              0.000304   else
  188              0.000621     return a:text
                              endif

FUNCTION  airline#extensions#branch#get_head()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/extensions/branch.vim line 290
Called 94 times
Total time:   0.285059
 Self time:   0.010607

count  total (s)   self (s)
   94   0.268499   0.002191   let head = airline#extensions#branch#head()
   94   0.003344   0.002357   let winwidth = get(airline#parts#get('branch'), 'minwidth', 120)
   94              0.000964   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
   94   0.009258   0.002101   let head = airline#util#shorten(head, winwidth, minwidth)
   94              0.000969   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
   94              0.001755   return empty(head) ? get(g:, 'airline#extensions#branch#empty_message', '') : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  282()
    Defined: ~/.vim/pack/coc/start/coc.nvim-release/autoload/coc/api.vim line 36
Called 31 times
Total time:   0.000507
 Self time:   0.000507

count  total (s)   self (s)
   31              0.000466   execute 'let g:'.a:name.'= a:value'

FUNCTION  289()
    Defined: ~/.vim/pack/coc/start/coc.nvim-release/autoload/coc/api.vim line 68
Called 30 times
Total time:   0.009304
 Self time:   0.005618

count  total (s)   self (s)
   30              0.000272   let res = []
  120              0.000529   for [key, arglist] in a:calls
   90              0.000657     let name = key[5:]
   90              0.000239     try
   90   0.005678   0.001992       call add(res, call(s:funcs[name], arglist))
                                catch /.*/
                                  return [res, v:exception]
   90              0.000181     endtry
  120              0.000225   endfor
   30              0.000145   return [res, v:null]

FUNCTION  coc#rpc#notify()
    Defined: ~/.vim/pack/coc/start/coc.nvim-release/autoload/coc/rpc.vim line 90
Called 50 times
Total time:   0.010415
 Self time:   0.002088

count  total (s)   self (s)
   50   0.001762   0.000895   if !coc#rpc#ready() | return '' | endif
   50   0.008434   0.000974   call s:client['notify'](a:method, a:args)
   50              0.000130   return ''

FUNCTION  295()
    Defined: ~/.vim/pack/coc/start/coc.nvim-release/autoload/coc/api.vim line 98
Called 31 times
Total time:   0.002458
 Self time:   0.001855

count  total (s)   self (s)
                              " command that could cause cursor vanish
   31              0.000907   if a:command =~# '^echo' || a:command =~# '^redraw' || a:command =~# '^sign place'
   30              0.000494     call timer_start(0, {-> s:execute(a:command)})
    1              0.000002   else
    1   0.000707   0.000104     execute a:command
   31              0.000051   endif

FUNCTION  296()
    Defined: ~/.vim/pack/coc/start/coc.nvim-release/autoload/coc/api.vim line 107
Called 5 times
Total time:   0.000338
 Self time:   0.000148

count  total (s)   self (s)
    5   0.000330   0.000140   return eval(a:expr)

FUNCTION  airline#util#prepend()
    Defined: ~/.vim/pack/bundles/start/vim-airline/autoload/airline/util.vim line 57
Called 376 times
Total time:   0.008127
 Self time:   0.008127

count  total (s)   self (s)
  376              0.002822   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  376              0.000617   endif
  376              0.003113   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>82_PlatformSlash()
    Defined: ~/.vim/pack/bundles/start/vim-fugitive/autoload/fugitive.vim line 99
Called 188 times
Total time:   0.003604
 Self time:   0.003604

count  total (s)   self (s)
  188              0.001409   if exists('+shellslash') && !&shellslash
                                return tr(a:path, '/', '\')
  188              0.000335   else
  188              0.000643     return a:path
                              endif

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   94   0.285059   0.010607  airline#extensions#branch#get_head()
   94   0.266308   0.007396  airline#extensions#branch#head()
   94   0.234374   0.013356  <SNR>89_update_branch()
   94   0.202973   0.009111  <SNR>89_update_git_branch()
   94   0.190227   0.004882  FugitiveHead()
   94   0.183994   0.014693  fugitive#Head()
  188   0.169301   0.112085  fugitive#Find()
   30   0.165404             <SNR>103_execute()
  188   0.030809   0.004176  <SNR>82_Tree()
   94   0.027101             airline#check_mode()
  188   0.026633   0.006363  FugitiveWorkTree()
   94   0.024538   0.021088  <SNR>89_update_untracked()
  658   0.018814             airline#util#append()
   94   0.018045   0.017141  <SNR>89_update_hg_branch()
  282   0.015795   0.012421  FugitiveGitDir()
  658   0.014578   0.012220  airline#util#wrap()
  188   0.014500   0.009548  airline#util#shorten()
   94   0.013004   0.012005  airline#extensions#fugitiveline#bufname()
  188   0.012794             airline#extensions#coc#get()
  188   0.012453             fugitive#CommonDir()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   30              0.165404  <SNR>103_execute()
  188   0.169301   0.112085  fugitive#Find()
   94              0.027101  airline#check_mode()
   94   0.024538   0.021088  <SNR>89_update_untracked()
  658              0.018814  airline#util#append()
   94   0.018045   0.017141  <SNR>89_update_hg_branch()
   94   0.183994   0.014693  fugitive#Head()
   94   0.234374   0.013356  <SNR>89_update_branch()
  188              0.012794  airline#extensions#coc#get()
  188              0.012453  fugitive#CommonDir()
  282   0.015795   0.012421  FugitiveGitDir()
  470              0.012398  airline#util#winwidth()
  658   0.014578   0.012220  airline#util#wrap()
   94   0.013004   0.012005  airline#extensions#fugitiveline#bufname()
   94   0.285059   0.010607  airline#extensions#branch#get_head()
  564              0.010350  <SNR>82_Slash()
   48              0.009643  <SNR>22_Highlight_Matching_Pair()
  188   0.014500   0.009548  airline#util#shorten()
   94   0.202973   0.009111  <SNR>89_update_git_branch()
  376              0.008127  airline#util#prepend()

